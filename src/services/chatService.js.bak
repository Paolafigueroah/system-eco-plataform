import { 
  ref, 
  push, 
  set, 
  get, 
  query, 
  orderByChild, 
  equalTo, 
  onValue, 
  off,
  serverTimestamp,
  update
} from 'firebase/database';
import { database } from '../firebaseConfig';

// Servicio para el sistema de chat usando Firebase Realtime Database
export const chatService = {
  // Crear una nueva conversación
  createConversation: async (participants, initialMessage = null) => {
    try {
      const conversationRef = ref(database, 'conversations');
      const newConversationRef = push(conversationRef);
      
      const conversationData = {
        id: newConversationRef.key,
        participants: participants.sort(), // Ordenar para consistencia
        lastMessage: initialMessage,
        lastMessageTime: serverTimestamp(),
        createdAt: serverTimestamp(),
        updatedAt: serverTimestamp()
      };

      await set(newConversationRef, conversationData);
      return { success: true, conversationId: newConversationRef.key };
    } catch (error) {
      console.error('Error al crear conversación:', error);
      return { success: false, error: error.message };
    }
  },

  // Obtener conversaciones de un usuario
  getUserConversations: (userId, callback) => {
    const conversationsRef = ref(database, 'conversations');
    const userConversationsQuery = query(
      conversationsRef,
      orderByChild('participants'),
      equalTo(userId)
    );

    const unsubscribe = onValue(userConversationsQuery, (snapshot) => {
      const conversations = [];
      snapshot.forEach((childSnapshot) => {
        const conversation = childSnapshot.val();
        // Filtrar conversaciones donde el usuario es participante
        if (conversation.participants.includes(userId)) {
          conversations.push({
            ...conversation,
            id: childSnapshot.key
          });
        }
      });

      // Ordenar por última actividad
      conversations.sort((a, b) => {
        const timeA = a.lastMessageTime ? new Date(a.lastMessageTime).getTime() : 0;
        const timeB = b.lastMessageTime ? new Date(b.lastMessageTime).getTime() : 0;
        return timeB - timeA;
      });

      callback({ success: true, data: conversations });
    }, (error) => {
      console.error('Error al obtener conversaciones:', error);
      callback({ success: false, error: error.message });
    });

    return unsubscribe;
  },

  // Enviar un mensaje
  sendMessage: async (conversationId, messageData) => {
    try {
      const messagesRef = ref(database, `conversations/${conversationId}/messages`);
      const newMessageRef = push(messagesRef);
      
      const message = {
        id: newMessageRef.key,
        ...messageData,
        timestamp: serverTimestamp(),
        read: false
      };

      await set(newMessageRef, message);

      // Actualizar la conversación con el último mensaje
      const conversationRef = ref(database, `conversations/${conversationId}`);
      await update(conversationRef, {
        lastMessage: {
          text: messageData.text,
          senderId: messageData.senderId,
          timestamp: message.timestamp
        },
        lastMessageTime: message.timestamp,
        updatedAt: serverTimestamp()
      });

      return { success: true, messageId: newMessageRef.key };
    } catch (error) {
      console.error('Error al enviar mensaje:', error);
      return { success: false, error: error.message };
    }
  },

  // Obtener mensajes de una conversación
  getConversationMessages: (conversationId, callback) => {
    const messagesRef = ref(database, `conversations/${conversationId}/messages`);
    const messagesQuery = query(messagesRef, orderByChild('timestamp'));

    const unsubscribe = onValue(messagesQuery, (snapshot) => {
      const messages = [];
      snapshot.forEach((childSnapshot) => {
        messages.push({
          ...childSnapshot.val(),
          id: childSnapshot.key
        });
      });

      // Ordenar por timestamp
      messages.sort((a, b) => {
        const timeA = a.timestamp ? new Date(a.timestamp).getTime() : 0;
        const timeB = b.timestamp ? new Date(b.timestamp).getTime() : 0;
        return timeA - timeB;
      });

      callback({ success: true, data: messages });
    }, (error) => {
      console.error('Error al obtener mensajes:', error);
      callback({ success: false, error: error.message });
    });

    return unsubscribe;
  },

  // Marcar mensajes como leídos
  markMessagesAsRead: async (conversationId, userId) => {
    try {
      const messagesRef = ref(database, `conversations/${conversationId}/messages`);
      const messagesQuery = query(
        messagesRef,
        orderByChild('senderId'),
        equalTo(userId)
      );

      const snapshot = await get(messagesQuery);
      const updates = {};

      snapshot.forEach((childSnapshot) => {
        const message = childSnapshot.val();
        if (message.senderId !== userId && !message.read) {
          updates[`conversations/${conversationId}/messages/${childSnapshot.key}/read`] = true;
        }
      });

      if (Object.keys(updates).length > 0) {
        await update(ref(database), updates);
      }

      return { success: true };
    } catch (error) {
      console.error('Error al marcar mensajes como leídos:', error);
      return { success: false, error: error.message };
    }
  },

  // Obtener conversación por ID
  getConversation: async (conversationId) => {
    try {
      const conversationRef = ref(database, `conversations/${conversationId}`);
      const snapshot = await get(conversationRef);
      
      if (snapshot.exists()) {
        return { 
          success: true, 
          data: { ...snapshot.val(), id: snapshot.key } 
        };
      } else {
        return { success: false, error: 'Conversación no encontrada' };
      }
    } catch (error) {
      console.error('Error al obtener conversación:', error);
      return { success: false, error: error.message };
    }
  },

  // Buscar conversación existente entre dos usuarios
  findConversation: async (userId1, userId2) => {
    try {
      const conversationsRef = ref(database, 'conversations');
      const userConversationsQuery = query(
        conversationsRef,
        orderByChild('participants'),
        equalTo(userId1)
      );

      const snapshot = await get(userConversationsQuery);
      let existingConversation = null;

      snapshot.forEach((childSnapshot) => {
        const conversation = childSnapshot.val();
        if (conversation.participants.includes(userId2)) {
          existingConversation = { ...conversation, id: childSnapshot.key };
        }
      });

      return { 
        success: true, 
        data: existingConversation,
        exists: !!existingConversation
      };
    } catch (error) {
      console.error('Error al buscar conversación:', error);
      return { success: false, error: error.message };
    }
  },

  // Eliminar conversación
  deleteConversation: async (conversationId) => {
    try {
      const conversationRef = ref(database, `conversations/${conversationId}`);
      await set(conversationRef, null);
      return { success: true };
    } catch (error) {
      console.error('Error al eliminar conversación:', error);
      return { success: false, error: error.message };
    }
  },

  // Obtener conversación o crear una nueva
  getOrCreateConversation: async (userId1, userId2, initialMessage = null) => {
    try {
      // Buscar conversación existente
      const searchResult = await chatService.findConversation(userId1, userId2);
      
      if (searchResult.success && searchResult.exists) {
        return { 
          success: true, 
          conversationId: searchResult.data.id,
          isNew: false 
        };
      }

      // Crear nueva conversación
      const createResult = await chatService.createConversation(
        [userId1, userId2], 
        initialMessage
      );

      if (createResult.success) {
        return { 
          success: true, 
          conversationId: createResult.conversationId,
          isNew: true 
        };
      }

      return createResult;
    } catch (error) {
      console.error('Error al obtener/crear conversación:', error);
      return { success: false, error: error.message };
    }
  },

  // Suscribirse a cambios en tiempo real
  subscribeToConversation: (conversationId, callback) => {
    const conversationRef = ref(database, `conversations/${conversationId}`);
    
    const unsubscribe = onValue(conversationRef, (snapshot) => {
      if (snapshot.exists()) {
        const conversation = { ...snapshot.val(), id: snapshot.key };
        callback({ success: true, data: conversation });
      } else {
        callback({ success: false, error: 'Conversación no encontrada' });
      }
    }, (error) => {
      console.error('Error al suscribirse a conversación:', error);
      callback({ success: false, error: error.message });
    });

    return unsubscribe;
  },

  // Obtener estadísticas de chat para un usuario
  getUserChatStats: async (userId) => {
    try {
      const conversationsRef = ref(database, 'conversations');
      const userConversationsQuery = query(
        conversationsRef,
        orderByChild('participants'),
        equalTo(userId)
      );

      const snapshot = await get(userConversationsQuery);
      let totalConversations = 0;
      let totalUnreadMessages = 0;
      let lastActivity = null;

      snapshot.forEach((childSnapshot) => {
        const conversation = childSnapshot.val();
        if (conversation.participants.includes(userId)) {
          totalConversations++;
          
          if (conversation.lastMessageTime) {
            const messageTime = new Date(conversation.lastMessageTime);
            if (!lastActivity || messageTime > lastActivity) {
              lastActivity = messageTime;
            }
          }
        }
      });

      return {
        success: true,
        data: {
          totalConversations,
          totalUnreadMessages,
          lastActivity
        }
      };
    } catch (error) {
      console.error('Error al obtener estadísticas de chat:', error);
      return { success: false, error: error.message };
    }
  }
};

// Utilidades para el chat
export const chatUtils = {
  // Formatear timestamp del mensaje
  formatMessageTime: (timestamp) => {
    if (!timestamp) return '';
    
    const now = new Date();
    const messageTime = new Date(timestamp);
    const diffTime = Math.abs(now - messageTime);
    const diffMinutes = Math.ceil(diffTime / (1000 * 60));
    const diffHours = Math.ceil(diffTime / (1000 * 60 * 60));
    const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));

    if (diffMinutes < 1) return 'Ahora';
    if (diffMinutes < 60) return `Hace ${diffMinutes} min`;
    if (diffHours < 24) return `Hace ${diffHours} h`;
    if (diffDays === 1) return 'Ayer';
    if (diffDays < 7) return `Hace ${diffDays} días`;
    
    return messageTime.toLocaleDateString('es-ES', {
      day: '2-digit',
      month: '2-digit',
      year: '2-digit'
    });
  },

  // Obtener iniciales del nombre
  getInitials: (name) => {
    if (!name) return '?';
    return name
      .split(' ')
      .map(word => word.charAt(0))
      .join('')
      .toUpperCase()
      .slice(0, 2);
  },

  // Truncar texto largo
  truncateText: (text, maxLength = 50) => {
    if (!text || text.length <= maxLength) return text;
    return text.substring(0, maxLength) + '...';
  },

  // Validar mensaje
  validateMessage: (text) => {
    if (!text || text.trim().length === 0) {
      return { isValid: false, error: 'El mensaje no puede estar vacío' };
    }
    
    if (text.trim().length > 1000) {
      return { isValid: false, error: 'El mensaje es demasiado largo (máximo 1000 caracteres)' };
    }

    return { isValid: true };
  }
};

export default chatService;
